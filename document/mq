RabbitMQ提供了6种模式，分别是HelloWorld(一对一)，Work Queue，Publish/Subscribe，Routing，Topics，RPC Request/reply。
其中Publish/Subscribe，Routing，Topics三种模式可以统一归为Exchange模式，只是创建时交换机的类型不一样，分别是fanout、direct、topic。

三种交换机模式：

	Direct Exchange – 处理路由键。
	需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。
	如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。(一对一的匹配才会转发)
	Message 通过路由键  发送到指定 交换机，交换机根据路由键 分发到  绑定该路由键的队列   消费者接收

	注意： 同一个exchange 下的一个路由键可以绑定多个队列, 该路由下的消息可以发送到对应的多个队列

	 Fanout Exchange – 不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。
	 很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的（也号称广播转发消息，会转发到所有绑定此交换机的队列上）

	 Topic Exchange – 将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。
	 因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.*” 只会匹配到“audit.irs”。（匹配才会转发）



	 注意：
	 如果一个队列使用程序初始化绑定到一个路由上，那么如果修改队列使其绑定到其他exchange上，结果是：该队列绑定到两个exchange上；两个exchange上对应的消息队列都可以接收到；



	 测试过程遇到的问题：原因未知
	 仅仅使用配置类 配置为手动确认消息模式：消费者接收到消息，正常处理没有异常，即使不确认，消息会自动确认。如果配置文件中配置了
	     listener:
         simple:
           acknowledge-mode: manual

                    direct: #这个貌似没用
                      acknowledge-mode: manual
      消费者接收到消息，正常处理没有异常，消息必须手动确认。



消息手动确认模式的几点说明

    监听的方法内部必须使用channel进行消息确认，包括消费成功或消费失败  ----手动确认在异常前，即使有异常也会确认，造成消息丢失，所以确认方法应放在最后

    如果不手动确认，也不抛出异常，消息不会自动重新推送（包括其他消费者），因为对于rabbitmq来说始终没有接收到消息消费是否成功的确认，并且Channel是在消费端有缓存的，没有断开连接

    如果rabbitmq断开，连接后会自动重新推送（不管是网络问题还是宕机）

    如果消费端应用重启，消息会自动重新推送

    如果消费端处理消息的时候宕机，消息会自动推给其他的消费者

    如果监听消息的方法抛出异常，消息会按照listener.retry的配置进行重发，但是重发次数完了之后还抛出异常的话，消息不会重发（也不会重发到其他消费者），只有应用重启后会重新推送。因为retry是消费端内部处理的，
    包括异常也是内部处理，对于rabbitmq是不知道的



在RabbitMQ中，一共有三种消息的“死亡”形式：
消息被拒绝。通过调用basic.reject或者basic.nack并且设置的requeue参数为false。
消息因为设置了TTL而过期。
消息进入了一条已经达到最大长度的队列。